
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handler: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">billing_enginee/api/handler/loan_handler.go (30.0%)</option>
				
				<option value="file1">billing_enginee/api/routes/loan_routes.go (100.0%)</option>
				
				<option value="file2">billing_enginee/internal/entity/customer_entity.go (80.0%)</option>
				
				<option value="file3">billing_enginee/internal/entity/loan_entity.go (85.7%)</option>
				
				<option value="file4">billing_enginee/internal/entity/payment_entity.go (36.4%)</option>
				
				<option value="file5">billing_enginee/internal/repository/customer_repository.go (72.7%)</option>
				
				<option value="file6">billing_enginee/internal/repository/loan_repository.go (40.0%)</option>
				
				<option value="file7">billing_enginee/internal/repository/payment_repository.go (0.0%)</option>
				
				<option value="file8">billing_enginee/internal/usecase/loan_usecase.go (52.8%)</option>
				
				<option value="file9">billing_enginee/internal/usecase/payment_usecase.go (0.0%)</option>
				
				<option value="file10">billing_enginee/pkg/db.go (42.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package handler

import (
        "billing_enginee/internal/usecase"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
)

type LoanHandler struct {
        loanUsecase usecase.LoanUsecase
}

func NewLoanHandler(loanUsecase usecase.LoanUsecase) *LoanHandler <span class="cov8" title="1">{
        return &amp;LoanHandler{
                loanUsecase: loanUsecase,
        }
}</span>

type CreateLoanRequest struct {
        CustomerID uint    `json:"customer_id" binding:"required"`
        Name       string  `json:"name" binding:"required"`
        Email      string  `json:"email" binding:"required"`
        Amount     float64 `json:"amount" binding:"required"`
        TermWeeks  int     `json:"term_weeks" binding:"required"`
        Rates      float64 `json:"rates" binding:"required"`
}

func (h *LoanHandler) CreateLoan(c *gin.Context) <span class="cov8" title="1">{
        var request CreateLoanRequest

        // Validate the request payload
        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Create the loan via the usecase
        <span class="cov8" title="1">response, err := h.loanUsecase.CreateLoan(request.CustomerID, request.Name, request.Email, request.Amount, request.TermWeeks, request.Rates)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        // Return success response
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "loan_id":            strconv.FormatUint(uint64(response.LoanID), 10),
                "total_amount":       response.TotalAmount,
                "outstanding_amount": response.OutstandingAmount,
                "week":               response.Week,
                "due_date":           response.DueDate.Format("2006-01-02"),
        })</span>
}

func (h *LoanHandler) GetOutstanding(c *gin.Context) <span class="cov0" title="0">{
        loanIDParam := c.Param("loan_id")
        loanID, err := strconv.ParseUint(loanIDParam, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid loan ID"})
                return
        }</span>

        // Get outstanding payments via usecase
        <span class="cov0" title="0">response, err := h.loanUsecase.GetOutstanding(uint(loanID))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        // Return the response
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "loan_id":            strconv.FormatUint(uint64(response.LoanID), 10),
                "total_amount":       response.TotalAmount,
                "outstanding_amount": response.OutstandingAmount,
                "due_date":           response.DueDate.Format("2006-01-02"),
                "weeks_outstanding":  response.WeeksOutstanding,
        })</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package routes

import (
        "billing_enginee/api/handler"
        "billing_enginee/internal/usecase"

        "github.com/gin-gonic/gin"
)

func SetupRouter(loanUsecase usecase.LoanUsecase) *gin.Engine <span class="cov8" title="1">{
        router := gin.Default()

        // Initialize the loan handler
        loanHandler := handler.NewLoanHandler(loanUsecase)

        // Define routes
        v1 := router.Group("/api/v1")
        </span><span class="cov8" title="1">{
                // Create loan route
                v1.POST("/loans", loanHandler.CreateLoan)
                // Get outstanding payments route
                v1.GET("/loans/:loan_id/outstanding", loanHandler.GetOutstanding)
        }</span>

        <span class="cov8" title="1">return router</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package entity

import "billing_enginee/internal/model"

type Customer struct {
        id    uint
        name  string
        email string
}

func CreateCustomer(id uint, name, email string) *Customer <span class="cov8" title="1">{
        return &amp;Customer{
                id:    id,
                name:  name,
                email: email,
        }
}</span>

func MakeCustomer(m *model.Customer) *Customer <span class="cov0" title="0">{
        return &amp;Customer{
                id:    m.ID,
                name:  m.Name,
                email: m.Email,
        }
}</span>

func (c *Customer) ToModel() *model.Customer <span class="cov8" title="1">{
        return &amp;model.Customer{
                ID:    c.id,
                Name:  c.name,
                Email: c.email,
        }
}</span>

func (c *Customer) SetID(id uint) <span class="cov8" title="1">{
        c.id = id
}</span>

func (c *Customer) GetID() uint <span class="cov8" title="1">{
        return c.id
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package entity

import (
        "billing_enginee/internal/model"
        "time"
)

type Loan struct {
        id          uint
        customerID  uint
        amount      float64
        totalAmount float64
        status      string
        termWeeks   int
        rates       float64
        createdAt   time.Time
        updatedAt   time.Time
}

func CreateLoan(customerID uint, amount float64, termWeeks int, rates float64) *Loan <span class="cov1" title="1">{
        totalAmount := amount + (amount * rates / 100)
        return &amp;Loan{
                customerID:  customerID,
                amount:      amount,
                totalAmount: totalAmount,
                status:      "open",
                termWeeks:   termWeeks,
                rates:       rates,
                createdAt:   time.Now(),
        }
}</span>

func MakeLoan(m *model.Loan) *Loan <span class="cov0" title="0">{
        return &amp;Loan{
                id:          m.ID,
                customerID:  m.CustomerID,
                amount:      m.Amount,
                totalAmount: m.TotalAmount,
                status:      m.Status,
                termWeeks:   m.TermWeeks,
                rates:       m.Rates,
                createdAt:   m.CreatedAt,
                updatedAt:   m.UpdatedAt,
        }
}</span>

func (l *Loan) ToModel() *model.Loan <span class="cov1" title="1">{
        return &amp;model.Loan{
                ID:          l.id,
                CustomerID:  l.customerID,
                Amount:      l.amount,
                TotalAmount: l.totalAmount,
                Status:      l.status,
                TermWeeks:   l.termWeeks,
                Rates:       l.rates,
                CreatedAt:   l.createdAt,
                UpdatedAt:   l.updatedAt,
        }
}</span>

func (l *Loan) SetID(id uint) <span class="cov1" title="1">{
        l.id = id
}</span>

func (l *Loan) GetID() uint <span class="cov10" title="51">{
        return l.id
}</span>

func (l *Loan) TotalAmount() float64 <span class="cov2" title="2">{
        return l.totalAmount
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package entity

import (
        "billing_enginee/internal/model"
        "time"
)

type Payment struct {
        id      uint
        loanID  uint
        loan    *Loan // Reference to the associated loan
        week    int
        amount  float64
        dueDate time.Time
        status  string
}

func CreatePayment(loanID uint, week int, amount float64, dueDate time.Time, status string) *Payment <span class="cov10" title="50">{
        return &amp;Payment{
                loanID:  loanID,
                week:    week,
                amount:  amount,
                dueDate: dueDate,
                status:  status,
        }
}</span>

func MakePayment(m *model.Payment) *Payment <span class="cov0" title="0">{
        return &amp;Payment{
                id:      m.ID,
                loanID:  m.LoanID,
                week:    m.Week,
                amount:  m.Amount,
                dueDate: m.DueDate,
                status:  m.Status,
        }
}</span>

func (p *Payment) ToModel() *model.Payment <span class="cov10" title="50">{
        return &amp;model.Payment{
                ID:      p.id,
                LoanID:  p.loanID,
                Week:    p.week,
                Amount:  p.amount,
                DueDate: p.dueDate,
                Status:  p.status,
        }
}</span>

func (p *Payment) SetID(id uint) <span class="cov10" title="50">{
        p.id = id
}</span>

func (p *Payment) GetID() uint <span class="cov0" title="0">{
        return p.id
}</span>

// Getter for Amount
func (p *Payment) Amount() float64 <span class="cov0" title="0">{
        return p.amount
}</span>

// Getter for DueDate
func (p *Payment) DueDate() time.Time <span class="cov1" title="1">{
        return p.dueDate
}</span>

// Add a Loan() method to fetch the associated Loan entity
func (p *Payment) Loan() *Loan <span class="cov0" title="0">{
        return p.loan
}</span>

func (p *Payment) SetLoan(loan *Loan) <span class="cov0" title="0">{
        p.loan = loan
}</span>

func (p *Payment) Status() string <span class="cov0" title="0">{
        return p.status
}</span>

func (p *Payment) SetStatus(status string) <span class="cov0" title="0">{
        p.status = status
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package repository

import (
        "billing_enginee/internal/entity"
        "billing_enginee/internal/model"

        "gorm.io/gorm"
)

type CustomerRepository interface {
        SaveCustomer(customer *entity.Customer) error
        GetCustomerByID(customerID uint) (*entity.Customer, error)
}

type customerRepository struct {
        db *gorm.DB
}

func NewCustomerRepository(db *gorm.DB) CustomerRepository <span class="cov8" title="1">{
        return &amp;customerRepository{
                db: db,
        }
}</span>

func (r *customerRepository) SaveCustomer(customer *entity.Customer) error <span class="cov8" title="1">{
        // Convert entity.Customer to model.Customer
        customerModel := customer.ToModel()

        // Save customer to the database
        if err := r.db.Create(&amp;customerModel).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update entity with the generated ID
        <span class="cov8" title="1">customer.SetID(customerModel.ID)
        return nil</span>
}

func (r *customerRepository) GetCustomerByID(customerID uint) (*entity.Customer, error) <span class="cov8" title="1">{
        var customerModel model.Customer
        if err := r.db.First(&amp;customerModel, customerID).Error; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Convert model to entity
        <span class="cov0" title="0">customerEntity := entity.MakeCustomer(&amp;customerModel)
        return customerEntity, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package repository

import (
        "billing_enginee/internal/entity"
        "billing_enginee/internal/model"

        "gorm.io/gorm"
)

type LoanRepository interface {
        SaveLoan(loan *entity.Loan) error
        GetLoanByID(loanID uint) (*entity.Loan, error)
        SavePayments(payments []*entity.Payment) error
        GetOutstandingPayments(loanID uint) ([]*entity.Payment, error)
}

type loanRepository struct {
        db *gorm.DB
}

func NewLoanRepository(db *gorm.DB) LoanRepository <span class="cov1" title="1">{
        return &amp;loanRepository{
                db: db,
        }
}</span>

func (r *loanRepository) SaveLoan(loan *entity.Loan) error <span class="cov1" title="1">{
        // Convert entity.Loan to model.Loan
        loanModel := loan.ToModel()

        // Save loan to the database
        if err := r.db.Create(&amp;loanModel).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update entity with the generated ID
        <span class="cov1" title="1">loan.SetID(loanModel.ID)
        return nil</span>
}

func (r *loanRepository) GetLoanByID(loanID uint) (*entity.Loan, error) <span class="cov0" title="0">{
        var loanModel model.Loan
        if err := r.db.First(&amp;loanModel, loanID).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert model to entity
        <span class="cov0" title="0">loanEntity := entity.MakeLoan(&amp;loanModel)
        return loanEntity, nil</span>
}

func (r *loanRepository) SavePayments(payments []*entity.Payment) error <span class="cov1" title="1">{
        // Convert entity.Payment to model.Payment
        paymentModels := make([]model.Payment, len(payments))
        for i, payment := range payments </span><span class="cov10" title="50">{
                paymentModels[i] = *payment.ToModel()
        }</span>

        // Save payments to the database
        <span class="cov1" title="1">if err := r.db.Create(&amp;paymentModels).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update entities with generated IDs
        <span class="cov1" title="1">for i, paymentModel := range paymentModels </span><span class="cov10" title="50">{
                payments[i].SetID(paymentModel.ID)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (r *loanRepository) GetOutstandingPayments(loanID uint) ([]*entity.Payment, error) <span class="cov0" title="0">{
        var paymentModels []model.Payment

        // Query outstanding payments and preload the associated loan
        if err := r.db.Where("loan_id = ? AND status = ?", loanID, "outstanding").Preload("Loan").Find(&amp;paymentModels).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert to entities
        <span class="cov0" title="0">outstandingPayments := make([]*entity.Payment, len(paymentModels))
        for i, model := range paymentModels </span><span class="cov0" title="0">{
                payment := entity.MakePayment(&amp;model)

                // Convert model to entity and set the loan
                loanModel := model.Loan
                loan := entity.MakeLoan(&amp;loanModel)
                payment.SetLoan(loan)

                outstandingPayments[i] = payment
        }</span>

        <span class="cov0" title="0">return outstandingPayments, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package repository

import (
        "billing_enginee/internal/entity"
        "billing_enginee/internal/model"
        "time"

        "gorm.io/gorm"
)

type PaymentRepository interface {
        GetScheduledPaymentsDueInAWeek(nextWeek time.Time) ([]*entity.Payment, error)
        UpdatePaymentStatus(payment *entity.Payment) error
}

type paymentRepository struct {
        db *gorm.DB
}

func NewPaymentRepository(db *gorm.DB) PaymentRepository <span class="cov0" title="0">{
        return &amp;paymentRepository{
                db: db,
        }
}</span>

// Fetch payments due in a week with status 'scheduled'
func (r *paymentRepository) GetScheduledPaymentsDueInAWeek(nextWeek time.Time) ([]*entity.Payment, error) <span class="cov0" title="0">{
        var paymentModels []model.Payment

        if err := r.db.Where("due_date = ? AND status = ?", nextWeek, "scheduled").Find(&amp;paymentModels).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert models to entities
        <span class="cov0" title="0">payments := make([]*entity.Payment, len(paymentModels))
        for i, model := range paymentModels </span><span class="cov0" title="0">{
                payments[i] = entity.MakePayment(&amp;model)
        }</span>

        <span class="cov0" title="0">return payments, nil</span>
}

// Update the status of the payment
func (r *paymentRepository) UpdatePaymentStatus(payment *entity.Payment) error <span class="cov0" title="0">{
        return r.db.Model(&amp;model.Payment{}).Where("id = ?", payment.GetID()).Update("status", payment.Status()).Error
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package usecase

import (
        "billing_enginee/internal/entity"
        "billing_enginee/internal/repository"
        "errors"
        "time"

        "gorm.io/gorm"
)

type LoanUsecase interface {
        CreateLoan(customerID uint, name string, email string, amount float64, termWeeks int, rates float64) (*LoanResponse, error)
        GetOutstanding(loanID uint) (*OutstandingResponse, error)
}

type OutstandingResponse struct {
        LoanID            uint
        TotalAmount       float64
        OutstandingAmount float64
        DueDate           time.Time
        WeeksOutstanding  int
}

type loanUsecase struct {
        loanRepo     repository.LoanRepository
        customerRepo repository.CustomerRepository
}

func NewLoanUsecase(loanRepo repository.LoanRepository, customerRepo repository.CustomerRepository) LoanUsecase <span class="cov1" title="1">{
        return &amp;loanUsecase{
                loanRepo:     loanRepo,
                customerRepo: customerRepo,
        }
}</span>

type LoanResponse struct {
        LoanID            uint
        TotalAmount       float64
        OutstandingAmount float64
        Week              int
        DueDate           time.Time
}

func (u *loanUsecase) CreateLoan(customerID uint, name string, email string, amount float64, termWeeks int, rates float64) (*LoanResponse, error) <span class="cov1" title="1">{
        // Check if the customer exists
        customer, err := u.customerRepo.GetCustomerByID(customerID)
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        // Create and save customer if not found
                        customer = entity.CreateCustomer(customerID, name, email)
                        if err := u.customerRepo.SaveCustomer(customer); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }

        // Create loan entity
        <span class="cov1" title="1">loan := entity.CreateLoan(customer.GetID(), amount, termWeeks, rates)

        // Save loan to the repository
        if err := u.loanRepo.SaveLoan(loan); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Calculate payment amount
        <span class="cov1" title="1">paymentAmount := loan.TotalAmount() / float64(termWeeks)

        // Generate payments
        payments := []*entity.Payment{}
        for week := 1; week &lt;= termWeeks; week++ </span><span class="cov10" title="50">{
                status := "scheduled"
                if week == 1 </span><span class="cov1" title="1">{
                        status = "outstanding"
                }</span>

                <span class="cov10" title="50">dueDate := time.Now().AddDate(0, 0, 7*week)
                payments = append(payments, entity.CreatePayment(loan.GetID(), week, paymentAmount, dueDate, status))</span>
        }

        // Save payments to the repository
        <span class="cov1" title="1">if err := u.loanRepo.SavePayments(payments); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Prepare response
        <span class="cov1" title="1">response := &amp;LoanResponse{
                LoanID:            loan.GetID(),
                TotalAmount:       loan.TotalAmount(),
                OutstandingAmount: paymentAmount,
                Week:              1,
                DueDate:           payments[0].DueDate(),
        }

        return response, nil</span>
}

func (u *loanUsecase) GetOutstanding(loanID uint) (*OutstandingResponse, error) <span class="cov0" title="0">{
        // Fetch outstanding payments from the repository
        outstandingPayments, err := u.loanRepo.GetOutstandingPayments(loanID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(outstandingPayments) == 0 </span><span class="cov0" title="0">{
                return nil, nil // No outstanding payments
        }</span>

        // Sum outstanding amounts and get latest due date
        <span class="cov0" title="0">var totalOutstanding float64
        var latestDueDate time.Time
        for _, payment := range outstandingPayments </span><span class="cov0" title="0">{
                totalOutstanding += payment.Amount() // Corrected here
                if payment.DueDate().After(latestDueDate) </span><span class="cov0" title="0">{
                        latestDueDate = payment.DueDate()
                }</span>
        }

        // Get the total amount from the loan
        <span class="cov0" title="0">response := &amp;OutstandingResponse{
                LoanID:            loanID,
                TotalAmount:       outstandingPayments[0].Loan().TotalAmount(), // Corrected here
                OutstandingAmount: totalOutstanding,
                DueDate:           latestDueDate,
                WeeksOutstanding:  len(outstandingPayments),
        }

        return response, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package usecase

import (
        "billing_enginee/internal/repository"
        "log"
        "time"
)

type PaymentUsecase interface {
        RunDaily() error
}

type paymentUsecase struct {
        paymentRepo repository.PaymentRepository
}

func NewPaymentUsecase(paymentRepo repository.PaymentRepository) PaymentUsecase <span class="cov0" title="0">{
        return &amp;paymentUsecase{
                paymentRepo: paymentRepo,
        }
}</span>

func (pu *paymentUsecase) RunDaily() error <span class="cov0" title="0">{
        log.Println("Scheduler started: Checking for payments due in a week...")

        // Get the date one week from now
        nextWeek := time.Now().AddDate(0, 0, 7)

        // Fetch scheduled payments with a due date one week from now
        payments, err := pu.paymentRepo.GetScheduledPaymentsDueInAWeek(nextWeek)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error fetching payments: %v\n", err)
                return err
        }</span>

        // Update each payment's status to outstanding
        <span class="cov0" title="0">for _, payment := range payments </span><span class="cov0" title="0">{
                payment.SetStatus("outstanding")
                if err := pu.paymentRepo.UpdatePaymentStatus(payment); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error updating payment status for payment ID %d: %v\n", payment.GetID(), err)
                        return err
                }</span>
        }

        <span class="cov0" title="0">log.Printf("Scheduler completed: Processed %d payments.\n", len(payments))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package pkg

import (
        "database/sql"
        "fmt"
        "log"
        "os"
        "time"

        "github.com/joho/godotenv"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

var DB *gorm.DB
var err error

func InitDB() (*gorm.DB, *sql.DB, error) <span class="cov0" title="0">{
        // Read database connection parameters from the environment
        host := os.Getenv("DB_HOST")
        port := os.Getenv("DB_PORT")
        user := os.Getenv("DB_USER")
        password := os.Getenv("DB_PASSWORD")
        dbname := os.Getenv("DB_NAME")

        // Create the DSN (Data Source Name)
        dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=disable", host, user, password, dbname, port)

        // Open the database connection with custom GORM logger
        DB, err = gorm.Open(postgres.Open(dsn), &amp;gorm.Config{
                PrepareStmt: true, // Prepare statements for better performance
                QueryFields: true, // Log all query fields
                Logger: logger.New(
                        log.New(os.Stdout, "\r\n", log.LstdFlags), // Log to stdout
                        logger.Config{
                                SlowThreshold:             time.Second,   // Log slow queries
                                LogLevel:                  logger.Silent, // Set log level (adjust as needed)
                                IgnoreRecordNotFoundError: true,          // Ignore ErrRecordNotFound
                                Colorful:                  true,          // Enable colorful logs
                        },
                ),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        // Get the underlying sql.DB connection from the gorm.DB
        <span class="cov0" title="0">sqlDB, err := DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get sql.DB from gorm.DB: %w", err)
        }</span>

        <span class="cov0" title="0">return DB, sqlDB, nil</span>
}

func InitTestDB() (*gorm.DB, error) <span class="cov8" title="1">{
        // Load the .env.test file
        err = godotenv.Load("../../.env.test")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error loading .env.test file from config folder: %v", err)
        }</span>

        // Read environment variables for the test database
        <span class="cov8" title="1">host := os.Getenv("DB_HOST")
        port := os.Getenv("DB_PORT")
        user := os.Getenv("DB_USER")
        password := os.Getenv("DB_PASSWORD")
        dbname := os.Getenv("DB_NAME")

        // Create DSN for the test DB
        dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=disable", host, user, password, dbname, port)

        // Connect to the test database
        db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return db, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
